//tooltip 提示控件
namespace win.ui;

class tooltip{
	ctor(winform,tParam){
		if( ! winform ){ 
			error("第一个构造参数必须指定有效窗口",2) 
		} 
		this.parent = winform;
		this.hParent = winform[["hwnd"]] : winform;
		
		var style = 0x80000000/*_WS_POPUP*/ | 0x1 /*_TTS_ALWAYSTIP*/;
		if( tParam[["style"]] ) style = style | tParam[["style"]]; 
		this.hwnd = ::CreateWindowEx( 
			( tParam[["exstyle"]] or 0) | 0x8/*_WS_EX_TOPMOST*/, "tooltips_class32", , 
			style,0, 0, 0, 0, this.hParent, 0 );
		::SendMessageInt(this.hwnd, 0x418/*_TTM_SETMAXTIPWIDTH*/, 0, 410);
		
		if(  winform[["tooltipCtrl"]][["destroy"]] ){
			winform.tooltipCtrl.destroy();
		}
		winform[["tooltipCtrl"]] = this;
		this.create = function (tParam) {};
	};
	destroy = function(){
		if( this.hwnd ){
			::DestroyWindow(this.hwnd);
			this.hwnd = null;
		}
	};
	addTool = function(ctrl,text,flags){
		if( flags === null ) flags = 0;
		flags = flags | 1/*_TTF_IDISHWND*/ | 0x10/*_TTF_SUBCLASS*/; 
		
		var hCtrl = ctrl[["hwnd"]] : ctrl;
		
		var ti = TOOLINFO();
		ti.cbSize = ..raw.sizeof(ti);
		ti.uId = hCtrl;
		ti.uFlags = flags;
		ti.lpszText = topointer(text) == topointer(-1) ? topointer(text) : text;  
		::SendMessageByStruct(this.hwnd, 0x432/*_TTM_ADDTOOLW*/, 0, ti); 
		ti.hTooltip = this.hwnd;
		return ti;  
	};
	add = function(ctrls){
		var tis = {};
		for(k,v in ctrls) tis[k] = owner.addTool(winform[k],v);
		return tis;
	};
	delTool = function(ti){  
		::SendMessageByStruct(this.hwnd, 0x433/*_TTM_DELTOOLW*/, 0, ti);
	};
	updateTipText = function(ti,text){
		return ti.update(text);
	}; 
	track = function(ti,x,y){
		return ti.track(x,y);
	};
	popup = function(ti,active){
		if( ti  ){
			return ti.popup(active);
		}
		else{
			::SendMessage(this.hwnd,0x422/*_TTM_POPUP*/); 
		}
	};   
	setMaxWidth = function(width){
		::SendMessageInt(this.hwnd,0x418/*_TTM_SETMAXTIPWIDTH*/, 0, width);
	};
	setDelayTime = function(time,flag){
		::SendMessageInt(this.hwnd,0x403/*_TTM_SETDELAYTIME*/,flag,time : -1); 
	};
	setBkColor = function(clr){
		::SendMessageInt(this.hwnd,0x413/*_TTM_SETTIPBKCOLOR*/,0,clr); 
	};
	setTextColor = function(clr){
		::SendMessageInt(this.hwnd,0x414/*_TTM_SETTIPTEXTCOLOR*/,0,clr); 
	}; 
	update = function(){
		::SendMessage(this.hwnd,0x41D/*_TTM_UPDATE*/); 
	}; 
	relayEvent = function(msg){
		::SendMessageByStruct(this.hwnd,0x407/*_TTM_RELAYEVENT*/,0,msg); // @Deprecated
	};
}

namespace tooltip {

	class TOOLINFO {
 		INT cbSize;
 		INT uFlags;
 		ADDR hwnd;
 		ADDR uId;
 		struct rect = ::RECT();
 		pointer hinst;
 		ustring lpszText;
 		int lParam;
 		hTooltip = 0;
 		@_meta;
	}
	
	namespace TOOLINFO{
	    
	    _meta = {
	    	_get = {
	    		sendMessage = function(msg,wParam){
	    			::User32.SendMessage(owner.hTooltip,0x439/*_TTM_UPDATETIPTEXTW*/, wParam, owner);
	    		};
	    		updateTipText = function(text){
					owner.lpszText = topointer(text) == topointer(-1) ? topointer(text) : text;  
					::SendMessageByStruct(owner.hTooltip,0x439/*_TTM_UPDATETIPTEXTW*/, 0, owner);
				};
	    		popup = function(active){
	    			if( !active ){
						::SendMessageByStruct(owner.hTooltip,0x411/*_TTM_TRACKACTIVATE*/,0, owner); 
					}  
					else {
						::SendMessageByStruct(owner.hTooltip,0x411/*_TTM_TRACKACTIVATE*/, 1, owner); 
					} 	
	    		};
				track = function(x,y){
					if( ! ( owner.uFlags & 0x20/*_TTF_TRACK*/ ) ){
						error("创建该提示必须指定_TTF_TRACK选项",2)  
					}
					if( !x && x!==0 ){
						::SendMessageByStruct(owner.hTooltip,0x411/*_TTM_TRACKACTIVATE*/,0, owner);
						return;
					} 
					::SendMessageInt(owner.hTooltip,0x412/*_TTM_TRACKPOSITION*/, 0, ::MAKELONG(x,y));
					::SendMessageByStruct(owner.hTooltip,0x411/*_TTM_TRACKACTIVATE*/, 1, owner); 
				};
				delete = function(){
					::SendMessageByStruct(owner.hTooltip, 0x433/*_TTM_DELTOOLW*/, 0, owner);
				};
	    	}
	    }
	}
}

/**intellisense()
win.ui.tooltip = 提示控件
win.ui.tooltip() = !win_ui_tooltip.
win.ui.tooltip(.(winform,创建参数) = 创建提示控件,参数@2可省略\n参数@1为窗体对象 
!win_ui_tooltip.update() = 刷新
!win_ui_tooltip.setMaxWidth(.(宽度) = 设置提示框最大宽度
!win_ui_tooltip.setDelayTime(.(超时值,选项) = 设置超时值
!win_ui_tooltip.setTextColor(.(颜色值) = 设置文本颜色
!win_ui_tooltip.setBkColor(.(颜色值) = 设置背景颜色
!win_ui_tooltip.add(__) = 批量添加控件提示\n参数应使用一个表指定多个控件的提示文本,\n表成员的键为控件名,值为控件提示
!win_ui_tooltip.addTool( = 创建并返回toolInfo对象\n返回值可作为其他有关函数的参数
!win_ui_tooltip.addTool(.(hwnd,text,flags) = 除hwnd窗口句柄以外其他参数可选\ntext如果为-1则使用_TTN_NEEDTEXT消息回调获取文本\nflags为_TTF_前缀常量组合,例如：\n\n_TTF_TRACK 使用了该选项则可以使用track函数手动弹出提示
!win_ui_tooltip.delTool(.(toolInfo) = 删除提示\n参数@1请使用addTool函数的返回值
!win_ui_tooltip.updateTipText(.(toolInfo,text) = 更新提示文本\n参数@1请使用addTool函数的返回值
!win_ui_tooltip.track( = 弹出提示 
!win_ui_tooltip.track(.(toolInfo,x,y) = 在指定位置弹出提示\n参数@1请使用addTool函数的返回值,\n要使用此函数,addTool的最后一个参数必须指定 _TTF_TRACK
!win_ui_tooltip.track(.(toolInfo,false) = 关闭指定窗口的提示\n参数@1请使用addTool函数的返回值
!win_ui_tooltip.popup( = 弹出提示
!win_ui_tooltip.popup(.() = 在最后一次处理的鼠标消息所在位置弹出提示
!win_ui_tooltip.popup(.(toolInfo,true) = 显示提示\n参数@1请使用addTool函数的返回值
!win_ui_tooltip.popup(.(toolInfo,false) = 关闭提示\n参数@1请使用addTool函数的返回值
!win_ui_tooltip.addTool() = !winUiTooltipInfo.
end intellisense**/

/**intellisense(!winUiTooltipInfo)
sendMessage.sendMessage(msg,wParam) = 发送消息，用法参考此函数源码
updateTipText(.(text) = @text参数指定要更新的提示文本
popup(.(active) = 参数为true弹出提示,\n参数为false隐藏弹出的提示
track(.(x,y) = 在指定的坐标弹出提示,\n要使用此函数,创建控件提示时需要指定 _TTF_TRACK 选项
delete() = 删除提示
end intellisense**/

 /**intellisense()
_TTS_ALWAYSTIP=@1/*_TTS_ALWAYSTIP*/
_TTS_NOPREFIX=@2/*_TTS_NOPREFIX*/
_TTS_NOANIMATE=@0x10/*_TTS_NOANIMATE*/
_TTS_NOFADE=@0x20/*_TTS_NOFADE*/
_TTS_BALLOON=@0x40/*_TTS_BALLOON*/
_TTS_CLOSE=@0x80/*_TTS_CLOSE*/
_TTF_IDISHWND=@1/*_TTF_IDISHWND*/
_TTF_CENTERTIP=@2/*_TTF_CENTERTIP*/
_TTF_RTLREADING=@4/*_TTF_RTLREADING*/
_TTF_TRACK=@0x20/*_TTF_TRACK*/
_TTF_ABSOLUTE=@0x80/*_TTF_ABSOLUTE*/
_TTF_TRANSPARENT=@0x100/*_TTF_TRANSPARENT*/
_TTF_PARSELINKS=@0x1000/*_TTF_PARSELINKS*/
_TTF_DI_SETITEM=@0x8000/*_TTF_DI_SETITEM*/
_TTN_FIRST=@0xFFFFFDF8/*_TTN_FIRST*/
_TTN_LAST=@0xFFFFFFCA/*_TTN_LAST*/
_TTN_GETDISPINFO=@0xFFFFFDF8/*_TTN_GETDISPINFO*/
_TTN_SHOW=@0xFFFFFDF7/*_TTN_SHOW*/
_TTN_POP=@0xFFFFFDF6/*_TTN_POP*/
_TTN_LINKCLICK=@0xFFFFFDF5/*_TTN_LINKCLICK*/
_TTN_NEEDTEXT=@0xFFFFFDF8/*_TTN_NEEDTEXT*/
end intellisense**/